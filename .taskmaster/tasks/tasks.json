{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Foundation: Schema Definition and Style Extraction",
        "description": "Establish the type system for registries and extract existing inline styles into a dedicated CSS file to prepare for modularization.",
        "details": "1. Create `src/registry-explorer/core/registry.schema.ts`.\n2. Define typescript types `Registry`, `PrimaryFocus`, and `ComponentTag` based on the PRD specifications.\n3. Export constant arrays `PRIMARY_FOCUS_VALUES` and `COMPONENT_TAG_VALUES` to serve as the single source of truth for vocabularies.\n4. Extract all SPA-specific styles from the existing `public/index.html` (inside `<style>` tags) into a new file `public/styles/registry-explorer.css`.\n5. Update `public/index.html` to link to this new stylesheet and verify that the visual presentation remains unchanged.\n6. Ensure the schema accommodates required fields: name, url, description, primary_focus, component_tags.",
        "testStrategy": "Verify `registry.schema.ts` compiles without errors. Manually verify `index.html` renders identically to the previous version by opening it in a browser and checking layout/styles.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed. The task is straightforward: define TypeScript interfaces based on the PRD and move CSS from a <style> block to a .css file.",
        "updatedAt": "2025-12-10T19:13:45.392Z"
      },
      {
        "id": 2,
        "title": "Data Layer: Registry Dataset Implementation",
        "description": "Create the data module containing the real registry dataset, strictly typed against the new schema.",
        "details": "1. Create `src/registry-explorer/data/registries.data.ts`.\n2. Import `Registry` type from `../core/registry.schema`.\n3. Define and export a `const registries: ReadonlyArray<Registry>`.\n4. Populate this array with the real registry data as specified in the 'Community registry overview' (or migrate existing demo data from `index.html` if the overview doc is unavailable, structuring it to match the new schema).\n5. Ensure all `primary_focus` and `component_tags` values strictly adhere to the vocabularies defined in the schema.",
        "testStrategy": "TypeScript compilation check to ensure all data entries conform to the `Registry` interface. Verify no 'any' types are used for the data array.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed. Create a static data file matching the schema defined in Task 1.",
        "updatedAt": "2025-12-10T19:15:36.436Z"
      },
      {
        "id": 3,
        "title": "Core: Helper Modules for Labels and Configuration",
        "description": "Implement helper modules for text formatting and matrix configuration to support the UI and logic layers.",
        "details": "1. Create `src/registry-explorer/core/labels.ts`.\n2. Implement `focusLabel(focus: PrimaryFocus): string` to map keys (e.g., 'ai-chat') to readable text ('AI & Chatbot').\n3. Implement `componentLabel(tag: ComponentTag): string` to map tags to readable text.\n4. Create `src/registry-explorer/core/matrixColumns.ts`.\n5. Define and export `MATRIX_COLUMNS` as a `readonly ComponentTag[]`, selecting key components (e.g., button, chatbot, table, auth-form) for the matrix view columns as per PRD requirements.",
        "testStrategy": "Unit tests verifying that specific keys return expected labels and that `MATRIX_COLUMNS` contains valid tags from the schema.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed. Implement simple mapping functions and constant arrays.",
        "updatedAt": "2025-12-10T19:16:26.865Z"
      },
      {
        "id": 4,
        "title": "Core Logic: Grouping and Metrics Algorithms",
        "description": "Implement pure functions for filtering, grouping, and calculating metrics, decoupling logic from the UI.",
        "details": "1. Create `src/registry-explorer/core/grouping.ts`.\n2. Implement `filterRegistries(registries, searchTerm)`: returns a filtered array based on name, description, tags, etc.\n3. Implement `buildFocusGroups(registries, search)`: returns `FocusGroup[]` containing registries grouped by primary focus.\n4. Implement `buildComponentGroups(registries, search)`: returns `ComponentGroup[]` indexing registries by component tag.\n5. Implement `buildMatrixRows(registries, search, columns)`: returns `MatrixRow[]` for the coverage table.\n6. Implement `computeMetrics(registries, search)`: returns counts for the current view state.\n7. Ensure all functions are pure and deterministic.",
        "testStrategy": "Create unit tests in `tests/registry-explorer/grouping.test.ts` covering happy paths, empty search results, and edge cases for filtering logic.",
        "priority": "high",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Search and Filtering Logic",
            "description": "Develop the pure function to filter registries based on a search term against multiple fields.",
            "dependencies": [],
            "details": "Create `src/registry-explorer/core/grouping.ts` and export `filterRegistries(registries, searchTerm)`. The function should perform a case-insensitive check against registry names, descriptions, and tag arrays. If the search term is empty, return the original list.",
            "status": "done",
            "testStrategy": "Unit test `filterRegistries` with various search strings, ensuring matches in different fields are caught and empty search returns full set.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:07.931Z"
          },
          {
            "id": 2,
            "title": "Implement 'By Focus' Grouping Logic",
            "description": "Implement the transformation logic to group filtered registries by their primary focus category.",
            "dependencies": [
              1
            ],
            "details": "Export `buildFocusGroups(registries)` in `grouping.ts`. It should reduce the list of registries into an array of objects structured as `{ focus: PrimaryFocus, items: Registry[] }`, sorted or ordered according to business requirements.",
            "status": "done",
            "testStrategy": "Unit test `buildFocusGroups` with a mock array of registries to verify correct bucketing by primary focus key.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:07.938Z"
          },
          {
            "id": 3,
            "title": "Implement 'By Component' Grouping Logic",
            "description": "Develop the logic to create an inverted index of registries grouped by individual component tags.",
            "dependencies": [
              1
            ],
            "details": "Export `buildComponentGroups(registries)` in `grouping.ts`. Iterate through all registries and their component tags to build a list of `{ tag: ComponentTag, items: Registry[] }`. Ensure tags with no registries in the current set are handled appropriately.",
            "status": "done",
            "testStrategy": "Unit test `buildComponentGroups` to ensure a registry with multiple tags appears in multiple groups.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:07.940Z"
          },
          {
            "id": 4,
            "title": "Implement Matrix Generation and Metrics",
            "description": "Implement the logic for generating coverage matrix rows and calculating global metrics.",
            "dependencies": [
              1
            ],
            "details": "Export `buildMatrixRows` to map registries to rows containing boolean flags for specific columns defined in `MATRIX_COLUMNS`. Also implement `computeMetrics` to return an object with total registry counts and group counts for the UI.",
            "status": "done",
            "testStrategy": "Unit test `buildMatrixRows` to verify correct column mapping and `computeMetrics` for accurate counting.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:07.942Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down the implementation of core logic algorithms. 1. Implement search and filtering logic (fuzzy match, case-insensitive). 2. Implement 'By Focus' grouping logic. 3. Implement 'By Component' grouping logic. 4. Implement Matrix view row generation and coverage calculation.",
        "updatedAt": "2025-12-10T19:23:07.942Z"
      },
      {
        "id": 5,
        "title": "UI Layer: Focus View Implementation",
        "description": "Implement the rendering logic for the 'By Focus' view using the new grouping logic.",
        "details": "1. Create `src/registry-explorer/ui/focusView.ts`.\n2. Implement `renderFocusAside(root, groups, selectedFocus)`: renders the sidebar list of focus groups with counts.\n3. Implement `renderFocusContent(root, group, metrics)`: renders the grid of registry cards for the selected group.\n4. Use standard DOM API methods (createElement, appendChild) or template strings to generate markup matching the extracted CSS classes.\n5. Ensure empty states are handled gracefully.",
        "testStrategy": "Manual verification by invoking these functions with mock data and checking the DOM output. Ensure generated HTML matches the structure expected by `registry-explorer.css`.",
        "priority": "medium",
        "dependencies": [
          "1",
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Focus Sidebar Rendering Logic",
            "description": "Develop the sidebar renderer to display focus groups with counts and active state styling.",
            "dependencies": [],
            "details": "Create `src/registry-explorer/ui/focusView.ts` and implement the `renderFocusAside` function. This function must accept a root DOM element, an array of groups, and the currently selected focus ID. It should generate the navigation list using standard DOM APIs, ensuring the 'active' CSS class is applied to the selected item and badges for item counts are included.",
            "status": "done",
            "testStrategy": "Unit test `renderFocusAside` with mock group data to verify that the generated HTML structure (list items, classes) matches the expected sidebar layout.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:13.624Z"
          },
          {
            "id": 2,
            "title": "Implement Registry Card Grid Rendering Logic",
            "description": "Develop the main content renderer to display a grid of registry cards for the selected group.",
            "dependencies": [],
            "details": "In `src/registry-explorer/ui/focusView.ts`, implement `renderFocusContent`. This function takes a container element and a specific group of registries. It must iterate through the registries to create card elements (title, description, tags) and append them to the container. Include a fallback view for empty states (e.g., 'No registries found').",
            "status": "done",
            "testStrategy": "Invoke `renderFocusContent` with a mock registry group and assert that the correct number of card elements are appended to the container.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:13.626Z"
          },
          {
            "id": 3,
            "title": "Implement Focus View Switching and Event Handling",
            "description": "Wire up the sidebar and content areas to handle user interactions and group switching.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement the logic to attach click event listeners to the sidebar items generated by `renderFocusAside`. When a user selects a group, the handler should trigger an update to the `selectedFocus` state, re-render the sidebar to update the active class, and invoke `renderFocusContent` to refresh the main grid with the new group's data.",
            "status": "done",
            "testStrategy": "Manual verification: Click through different sidebar items in the browser and confirm that the main content area updates to show the correct registries without page reload.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:13.627Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split the UI implementation for the Focus View. 1. Create the Sidebar renderer for Focus groups (with active state handling). 2. Create the Card Grid renderer for the main content area. 3. Implement the DOM updates for switching between groups.",
        "updatedAt": "2025-12-10T19:23:13.627Z"
      },
      {
        "id": 6,
        "title": "UI Layer: Component and Matrix View Implementation",
        "description": "Implement the rendering logic for the 'By Component' and 'Matrix' views.",
        "details": "1. Create `src/registry-explorer/ui/componentView.ts`.\n2. Implement `renderComponentAside` and `renderComponentContent` to display component-based grouping.\n3. Create `src/registry-explorer/ui/matrixView.ts`.\n4. Implement `renderMatrixAside` (legend/columns) and `renderMatrixContent` (the table).\n5. Ensure the matrix table renders rows for registries and columns for `MATRIX_COLUMNS` with appropriate presence indicators (checkmarks/dots).",
        "testStrategy": "Manual verification with mock data. Check that the matrix table scrolls correctly and aligns with the columns.",
        "priority": "medium",
        "dependencies": [
          "1",
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Component View Rendering Logic",
            "description": "Create the component view module and implement functions to render the sidebar navigation and the main content area for component-based grouping.",
            "dependencies": [],
            "details": "Create `src/registry-explorer/ui/componentView.ts`. Implement `renderComponentAside` to list component tags with counts based on `ComponentGroup[]` data. Implement `renderComponentContent` to show a grid of registry cards filtered by the selected component tag, reusing card rendering styles where possible.",
            "status": "done",
            "testStrategy": "Manual verification: Ensure clicking a component tag in the sidebar correctly updates the content area to show only relevant registries.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:18.592Z"
          },
          {
            "id": 2,
            "title": "Implement Matrix View Sidebar and Legend",
            "description": "Create the matrix view module and implement the sidebar rendering, which acts as a legend or controller for the matrix columns.",
            "dependencies": [],
            "details": "Create `src/registry-explorer/ui/matrixView.ts`. Implement `renderMatrixAside` to display a static or interactive legend that corresponds to the `MATRIX_COLUMNS` defined in the core configuration. This prepares the layout for the complex table view.",
            "status": "done",
            "testStrategy": "Verify that the sidebar correctly iterates through `MATRIX_COLUMNS` and renders the appropriate labels or icons defined in the schema.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:18.593Z"
          },
          {
            "id": 3,
            "title": "Implement Matrix Table Rendering and Scrolling",
            "description": "Implement the main table rendering logic for the Matrix view, ensuring rows correspond to registries and columns to component tags, with overflow handling.",
            "dependencies": [
              2
            ],
            "details": "In `src/registry-explorer/ui/matrixView.ts`, implement `renderMatrixContent`. Generate a DOM structure (table or CSS grid) where rows represent registries and columns represent specific component features. logic must determine presence (checkmarks/dots) for each cell. Ensure the container handles horizontal scrolling for wide datasets.",
            "status": "done",
            "testStrategy": "Load with mock data containing various component combinations. Verify that the correct cells are marked and that horizontal scrolling is functional.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:18.595Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split the UI implementation for Component and Matrix Views. 1. Implement Component View sidebar and content rendering (similar to Focus view). 2. Implement the Matrix View specific sidebar (legend). 3. Implement the Matrix Table rendering, handling dynamic columns and scrolling.",
        "updatedAt": "2025-12-10T19:23:18.595Z"
      },
      {
        "id": 7,
        "title": "Shell: State Management and Orchestration",
        "description": "Create the main shell module to manage application state and coordinate view updates.",
        "details": "1. Create `src/registry-explorer/ui/shell.ts`.\n2. Define the application state (current view, search term, selections).\n3. Implement `initRegistryExplorer(options)` which accepts the registry data and DOM root elements.\n4. Add event listeners for tabs, search input, and sidebar items.\n5. Implement the main render loop that calls `grouping.ts` functions to derive data and then invokes the appropriate View module (Focus, Component, or Matrix) to update the DOM.\n6. Create `src/registry-explorer/ui/index.ts` to export `initRegistryExplorer`.",
        "testStrategy": "Manual E2E testing: verify clicking tabs switches views, typing in search filters results, and selecting pills updates the content area.",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Application State and Store Pattern",
            "description": "Create the state definition and a lightweight event emitter/store to manage application-wide data flow.",
            "dependencies": [],
            "details": "Define the `AppState` interface including properties for `currentView` (enum: 'focus', 'component', 'matrix'), `searchTerm` (string), and `activeFilters` (Set/Array). Implement a simple State Store pattern (e.g., `createStore` or a singleton class) with `getState`, `setState`, and `subscribe` methods to facilitate reactive updates without a framework.",
            "status": "done",
            "testStrategy": "Unit test the store: Verify `setState` updates the value and triggers subscribed callbacks correctly.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:24.648Z"
          },
          {
            "id": 2,
            "title": "Implement Shell Initialization and Event Wiring",
            "description": "Scaffold the shell module and bind global DOM event listeners to state updates.",
            "dependencies": [
              1
            ],
            "details": "Create `src/registry-explorer/ui/shell.ts`. Implement `initRegistryExplorer(data, domRoots)` to capture references to the navigation tabs, search input, and content containers. Add event listeners to these elements that dispatch updates to the State Store (defined in subtask 1), ensuring the search input handles debouncing if necessary.",
            "status": "done",
            "testStrategy": "Manual verification: Check that clicking navigation tabs and typing in the search box logs state changes to the console.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:24.650Z"
          },
          {
            "id": 3,
            "title": "Implement Main Render Orchestrator",
            "description": "Create the central render loop that reacts to state changes and delegates rendering to specific views.",
            "dependencies": [
              1,
              2
            ],
            "details": "In `shell.ts`, implement the subscriber callback for the State Store. This function should: 1. Receive the new state. 2. Invoke `grouping.ts` logic (filtering/grouping data based on search/filters). 3. clear the main content DOM. 4. Switch based on `currentView` to call the appropriate render function (`renderFocusView`, `renderComponentView`, or `renderMatrixView`). 5. Update active classes on navigation tabs.",
            "status": "done",
            "testStrategy": "Integration test: Mock the view renderers and verify that changing the state calls the correct view function with the filtered data.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:24.651Z"
          },
          {
            "id": 4,
            "title": "Finalize Entry Point and Integration",
            "description": "Create the public entry point for the UI module and handle initialization safety.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create `src/registry-explorer/ui/index.ts`. Export the `initRegistryExplorer` function. Add error handling within the initialization logic to ensure all required DOM root elements (e.g., `#registry-nav`, `#registry-content`) exist in the document before attempting to bind events, preventing runtime errors on malformed pages.",
            "status": "done",
            "testStrategy": "Manual test: specific verification that the application bootstraps correctly from the main `index.html` file.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T19:23:24.653Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Detail the application shell and state management. 1. Define the State interface and initial state. 2. Implement the State Store / Event Emitter pattern to handle updates. 3. Implement the main 'render' loop that diffs state or clears/repaints views. 4. Wire up global event listeners (navigation, search inputs) to trigger state changes.",
        "updatedAt": "2025-12-10T19:23:24.653Z"
      },
      {
        "id": 8,
        "title": "Integration: Entry Point and Legacy Fallback",
        "description": "Wire the new modular application into the HTML page and preserve the old version as a fallback.",
        "details": "1. Create `src/registry-explorer/entry.ts`.\n2. Implement code to query DOM elements (aside, header, body, inputs) and call `initRegistryExplorer` with the real data from `registries.data.ts`.\n3. Save the original `index.html` as `public/index.legacy.html`.\n4. Refactor `public/index.html` to remove all inline logic/data, leaving only the static container structure and a `<script type='module' src='/src/registry-explorer/entry.ts'>` tag (adjusting path for the build system/bundler used).",
        "testStrategy": "Load `public/index.html` in a browser (via local server). Verify the app initializes correctly with real data. Check that no console errors occur.",
        "priority": "high",
        "dependencies": [
          "2",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Separate the integration work. 1. Set up the new entry point script and DOM mounting logic. 2. Refactor the existing index.html to support the dual mode (legacy backup vs new module loading).",
        "updatedAt": "2025-12-10T19:21:08.456Z"
      },
      {
        "id": 9,
        "title": "Quality Assurance: Unit Tests for Core Logic",
        "description": "Ensure the core logic is robust with comprehensive unit tests.",
        "details": "1. Create/Update `tests/registry-explorer/grouping.test.ts`.\n2. Add test cases for `filterRegistries` (case insensitivity, partial matches).\n3. Add test cases for `buildFocusGroups` and `buildComponentGroups` (correct counts, sorting).\n4. Add test cases for `buildMatrixRows` (correct boolean flags).\n5. Create `tests/registry-explorer/matrixColumns.test.ts` to validate column configuration.\n6. Ensure at least 80% coverage for core logic files.",
        "testStrategy": "Run `npm test` (or project test command). All tests must pass. Check coverage report if available.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed. Write standard unit tests for the pure functions developed in Task 4.",
        "updatedAt": "2025-12-10T19:22:07.472Z"
      },
      {
        "id": 10,
        "title": "Documentation and Accessibility",
        "description": "Document the data maintenance process and ensure basic accessibility standards.",
        "details": "1. Create `docs/registry-explorer-data.md`.\n2. Document the `Registry` schema, allowed values for vocabularies, and the process for adding a new registry.\n3. Review the UI modules (`focusView`, `componentView`, etc.) to ensure interactive elements (tabs, pills) are keyboard accessible (tab index, focus styles).\n4. Add ARIA labels where necessary.",
        "testStrategy": "Review generated documentation for clarity. Perform a keyboard navigation audit (Tab/Shift+Tab, Enter/Space) on the running application.",
        "priority": "low",
        "dependencies": [
          "2",
          "5",
          "6",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed. Write documentation and perform a basic a11y audit.",
        "updatedAt": "2025-12-10T19:22:50.430Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-10T19:23:24.653Z",
      "taskCount": 10,
      "completedCount": 10,
      "tags": [
        "master"
      ],
      "created": "2025-12-10T19:29:26.139Z",
      "description": "Tasks for master context",
      "updated": "2025-12-10T19:29:26.139Z"
    }
  },
  "registry-explorer": {
    "tasks": [],
    "metadata": {
      "created": "2025-12-10T19:29:26.141Z",
      "updated": "2025-12-10T19:29:26.141Z",
      "description": "Tag created on 12/10/2025"
    }
  }
}